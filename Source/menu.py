# Импортируем библиотеку pygame, которая позволяет создавать игры и мультимедийные приложения.
import pygame

# Из модуля event библиотеки pygame используется класс event,  
# который отвечает за обработку событий, таких как нажатия клавиш или движения мыши.
from pygame import event

# Импортируем необходимые элементы из пользовательского модуля 'Source.init', 
# такие как 'menu' для графики меню, 'battle_button' для кнопки боя и 'screen' для экрана отображения.
from Source.init import menu, battle_button, screen


# Определяем класс Menu. 
# Этот класс будет отвечать за отображение меню игры и взаимодействие с пользователем.
class Menu:

    # Метод инициализации. 
    # Название должно быть __init__, чтобы работал конструктор класса
    def __init__(self):
        # Словарь 'objects' будет хранить все графические элементы интерфейса, 
        # как фон, так и кнопки, для легкого доступа по ключам.
        self.objects = {
            "background": menu,  # Устанавливаем фон меню в объект 'menu'.
            "buttons": battle_button  # Устанавливаем объект кнопки боя.
        }

    # Метод для обработки обновлений, связанным с взаимодействием пользователя.
    def handle_updates(self):
        # Получаем список всех событий, произошедших с момента последнего обновления.
        for event in pygame.event.get():
            # Проверяем, было ли нажатие левой кнопки мыши.
            if event.type == pygame.MOUSEBUTTONDOWN:  # Левый клик мыши
                # Если курсор мыши находится на кнопке, определяем это с помощью столкновения (collidepoint).
                if self.objects["buttons"].rect.collidepoint(event.pos):
                    # Возвращаем значение 1, чтобы указать, что кнопка была нажата.
                    return 1
        # Если кнопка не была нажата, возвращаем 0.
        return 0

    # Метод для отрисовки всех объектов меню на экране.
    def draw(self):
        # Создаем группу спрайтов с помощью значений из словаря 'objects' и отрисовываем их на 'screen'.
        pygame.sprite.Group(self.objects.values()).draw(screen)

    # Метод для обновления состояния меню, принимает параметр stage.
    def update(self, stage):
        # Обрабатываем обновления и возвращаем сумму с текущим значением stage.
        return self.handle_updates() + stage